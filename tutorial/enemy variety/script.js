//document.addEventListener('DOMContentLoaded '//fires when the initial html document has been loaded and parsed. But it doesn't wait for css and images    )
//load is the correct thing



document.addEventListener('DOMContentLoaded', function(){

const canvas = document.getElementById('canvas1');
const ctx = canvas.getContext('2d');
canvas.width = 500;
canvas.height = 700;




class Game{
    constructor(ctx, width, height){
        this.ctx=ctx;
        this.width=width;
        this.height =height;
        this.enemies = [];
        
        this.enemyInterval =1000; //defines the number of millisec before adding a new enemy to the game
        this.enemyTimer =0;//will count milisec from 0 to 400 over and over;
        console.log(this.enemies);


    }
    update(deltaTime){
        this.enemies = this.enemies.filter(object => !object.markedForDeletion)
        //.filter() method manipulates arrays
        //creates a new array with old elements, that pass the condition
        if(this.enemyTimer > this.enemyInterval){
            this.#addNewEnemy();//one enemy spawns
            this.enemyTimer=0;
        }else{
            this.enemyTimer+=deltaTime;//instead of hard coding +1 let's add Delta time this will make it more smother

        }
        this.enemies.forEach(object => object.update());

    }

    draw(){
        this.enemies.forEach(object => object.draw(this.ctx));

    }
    #addNewEnemy(){//a private method

        this.enemies.push(new Enemy(this));//passing this keyword allows us to pass everything inside the constructor of the game class


 

    }
}

class Enemy{
    constructor(game){
        this.game= game;
        console.log(this.game); 
        this.x=this.game.width;//will be at the start of the canvas // so that canvas knows where to draw them on canvas
        this.y=Math.random() * this.game.height;
        this.width=100;
        this.height=100;
        this.markedForDeletion=false;

    }
    update(){
        this.x--;//moves the enemy one pixel to the left of the canvas
        if(this.x <0 - this.width){
            this.markedForDeletion= true;
        }


    }
    draw(ctx){//this way this draw() method is using this.ctx that was passed along from the game object rather than passing global ctx
        ctx.fillRect(this.x, this.y, this.width, this.height);


    }

}

const game = new Game(ctx, canvas.width, canvas.height);    
let lastTime=1;
function animate(timeStamp){//timeStamp arguement is automatically generated by requestAnimationFrame
    ctx.clearRect(0,0, canvas.width, canvas.height);
    //some code
    //difference in frames in animation is called deltatime
    const deltaTime =timeStamp-lastTime;
    lastTime= timeStamp;
    //console.log(deltaTime);
    game.update(deltaTime);//passing deltaTime here means the spawning of enemy is synchronized in both slow and fast computers

    game.draw();
    requestAnimationFrame(animate);
};


animate(0);


});